// ====== 1) 配置：你的 Native Messaging Host 名称 ======
import browser from "webextension-polyfill";
import {sessionGet, sessionSet} from "../common/session_storage";
import {VideoMeta} from "../object/video_meta";
import {logYT} from "../common/debug_flags";

const KS_YT_COOKIE_KEY = "__KS_YT_COOKIE__";
const NATIVE_HOST = 'com.dessage.tweetcatapp';
// const NATIVE_HOST = 'com.dessage.ytdlp_bridge';

type NativeAction = 'start' | 'cookie' | 'check' | 'probe' | 'videoMeta';

interface NativeRequest {
    action: NativeAction;
    videoMeta?: VideoMeta;
    cookies?: string;
    hash?: string;
}

interface NativeResponse {
    ok: boolean;
    message?: string;
}

function toNetscape(cookies: Array<any>): string {
    const lines: string[] = [];
    lines.push("# Netscape HTTP Cookie File");
    lines.push("# This file is generated by yt-dlp.  Do not edit.");
    lines.push(""); // 与 Swift/yt-dlp 保持空行

    for (const c of cookies) {
        if (!IMPORTANT_COOKIES.has(c.name)) continue; // ✅ 新增过滤

        const domain: string = c.domain ?? "";
        const flag = domain.startsWith(".") ? "TRUE" : "FALSE";
        const path: string = c.path || "/";
        const secure = c.secure ? "TRUE" : "FALSE";
        const expiry =
            typeof c.expirationDate === "number" ? Math.floor(c.expirationDate) : 0;

        if (!c.name) continue;

        lines.push(
            [
                domain,
                flag,
                path,
                secure,
                expiry,
                c.name,
                c.value ?? "",
            ].join("\t")
        );
    }

    return lines.join("\n") + "\n"; // 严格 LF、末尾换行
}

// 计算 SHA256（保持不变）
async function sha256Hex(text: string): Promise<string> {
    const data = new TextEncoder().encode(text);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(digest))
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
}

// 读取 cookie → 转 Netscape → 打印（与 Swift/yt-dlp 同行文案）→ 写入 session
// 如果你把 session 的 key 改成了 videoId，就把入参传入对应的 key 即可。
export async function captureAndStoreYouTubeCookies(): Promise<void> {
    try {
        const cookies = await readYouTubeCookies();
        const netscape = toNetscape(cookies);
        const hash = await sha256Hex(netscape);

        // 打印内容与 Swift/yt-dlp 一致（包含两行头 + 空行 + 正文）
        logYT("[TweetCat] Netscape cookies:\n" + netscape);
        logYT("[TweetCat] Hash:", hash);

        await sessionSet(KS_YT_COOKIE_KEY, {netscape, hash});
    } catch (err) {
        console.error("[TweetCat] captureAndStoreYouTubeCookies failed:", err);
        throw err;
    }
}

// ====== 3) 发送工具：发消息到原生壳子（带超时&错误处理） ======
async function sendToNative(payload: NativeRequest, timeoutMs = 15000): Promise<NativeResponse> {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);

    try {
        const resp = await browser.runtime.sendNativeMessage(NATIVE_HOST, payload) as NativeResponse;
        return resp ?? {ok: false, message: 'empty native response'};
    } catch (err: any) {
        return {ok: false, message: String(err?.message || err)};
    } finally {
        clearTimeout(t);
    }
}

export async function videoMetaGot(videoMeta: VideoMeta) {
    logYT("---------->>>got a video meta:", videoMeta);

    let cookieData = await sessionGet(KS_YT_COOKIE_KEY);

    if (!cookieData) {
        await captureAndStoreYouTubeCookies();
        cookieData = await sessionGet(KS_YT_COOKIE_KEY);
    }

    const req: NativeRequest = {
        action: "videoMeta",
        videoMeta,
    };

    if (cookieData && cookieData.netscape && cookieData.hash) {
        req.cookies = cookieData.netscape;
        req.hash = cookieData.hash;
    }

    logYT("[TweetCat] NativeRequest:", req);

    const res = await sendToNative(req);
    if (!res.ok) {
        console.warn('[native][probe] failed:', res.message);
        return;
    }

    logYT('[native] ok:', JSON.stringify(res));
}

export async function openLocalApp(): Promise<boolean> {
    logYT("---------->>> start to open local app");
    const req: NativeRequest = {
        action: 'start',
    };

    const resp = await sendToNative(req);
    const success = !!(resp && (resp as any).ok === true);
    if (!success) {
        console.warn("failed to open local app:", resp?.message);
        return false;
    }

    return true;
}

export async function checkLocalApp(): Promise<boolean> {
    logYT("---------->>> start to check if local app installed");
    const req: NativeRequest = {
        action: 'check',
    };

    try {
        const resp = await browser.runtime.sendNativeMessage(NATIVE_HOST, req) as NativeResponse;
        return !!(resp && (resp as any).ok === true);
    } catch (err: any) {
        const msg = String(err?.message || err || "").toLowerCase();

        logYT("------>>>local host error message:", msg);
        // 1) 没找到 host（清单未放到正确目录 / name 不匹配 / 浏览器不是这个通道）
        if (msg.includes("specified native messaging host not found")) {
            return false;
        }

        // 2) 不允许访问（allowed_origins 的扩展 ID 不匹配）
        if (msg.includes("access to the specified native messaging host is forbidden")) {
            return false;
        }

        // 3) 能找到 host，但沟通失败（host 启动后退出/崩溃/通信异常）：
        //    就“算作已安装”，因为清单与路径都生效了，只是运行异常
        if (
            msg.includes("native host has exited") ||
            msg.includes("could not establish connection") ||
            msg.includes("error when communicating")
        ) {
            return true;
        }

        // 其它未知错误：保守起见当作未安装
        return false;
    }
}


async function sendUpdatedCookie() {
    logYT("---------->>>start to update cookie");

    let cookieData = await sessionGet(KS_YT_COOKIE_KEY);

    if (!cookieData) {
        logYT("------>>> no cookie data to update");
        return;
    }

    const cookies = cookieData.netscape;
    const hash = cookieData.hash;
    const req: NativeRequest = {
        action: "cookie",
        cookies,
        hash,
    };

    logYT("[TweetCat] NativeRequest:", req);

    const res = await sendToNative(req);
    if (!res.ok) {
        console.warn('[native][probe] failed:', res.message);
        return;
    }

    logYT('[native] ok:', JSON.stringify(res));
}


// 建议覆盖到常见 YouTube/Google 登录域
const COOKIE_URLS = [
    "https://www.youtube.com/",
    "https://m.youtube.com/",
    "https://studio.youtube.com/",
    "https://accounts.google.com/",
    "https://www.google.com/",
];

/**
 * 读取并打印各 URL 可用的 cookies，最终去重后返回
 */
async function readYouTubeCookies(): Promise<browser.Cookies.Cookie[]> {
    const collected: browser.Cookies.Cookie[] = [];

    for (const url of COOKIE_URLS) {
        try {
            const list = await browser.cookies.getAll({url});
            logYT(`[cookies] ${url} -> count=${list.length}`);
            collected.push(...list);
        } catch (e) {
            console.warn(`[cookies] failed for ${url}:`, e);
        }
    }

    // 去重：name + domain + path 作为键
    const map = new Map<string, browser.Cookies.Cookie>();
    for (const c of collected) {
        map.set(`${c.name}|${c.domain}|${c.path}`, c);
    }
    const uniques = [...map.values()];
    logYT(`[cookies] total unique=${uniques.length}`);

    // 额外打印关键 cookie 是否存在（便于快速判断登录态）
    const want = ["SAPISID", "__Secure-3PAPISID", "APISID", "SID", "HSID", "SSID"];
    const have = new Set(uniques.map((c) => c.name));
    logYT(
        `[cookies] presence: ` +
        want.map((k) => `${k}=${have.has(k) ? "YES" : "NO"}`).join(", ")
    );

    return uniques;
}


// 仅监听这些域名
const DOMAINS = ["youtube.com", "google.com", "accounts.google.com"];

//__Secure-1PSIDCC / __Secure-3PSIDCC

const IMPORTANT_COOKIES = new Set([
    // 身份/签名
    "SID", "HSID", "SSID", "APISID", "SAPISID",
    // 1P/3P 变体
    "__Secure-1PAPISID", "__Secure-3PAPISID",
    // 主会话
    "__Secure-1PSID", "__Secure-3PSID",
    // 会话粘性/安全附加
    "__Secure-1PSIDTS", "__Secure-3PSIDTS",
    "LOGIN_INFO",
    // 偏好/设备/访客（帮助通过风控/播放器层校验）
    "PREF", "YSC", "VISITOR_INFO1_LIVE", "DEVICE_INFO",
]);

function matchDomain(d: string) {
    return DOMAINS.some((suf) => d.endsWith(suf) || d.endsWith("." + suf));
}

async function refresh() {
    try {
        logYT("------------------>>>> read cookie again for update:");

        const cookies = await readYouTubeCookies();
        const netscape = toNetscape(cookies);
        const hash = await sha256Hex(netscape);

        logYT("[TweetCat] Netscape cookies:\n" + netscape);
        logYT("[TweetCat] Hash:", hash);

        await sessionSet(KS_YT_COOKIE_KEY, {netscape, hash});

        await sendUpdatedCookie();
    } catch (err) {
        console.error("[TweetCat] cookie watcher refresh failed:", err);
    }
}

async function onChanged(changeInfo: browser.Cookies.OnChangedChangeInfoType) {

    const c = changeInfo.cookie;
    const domain = c?.domain?.toLowerCase();
    if (!domain) return;
    if (!matchDomain(domain)) return;

    // 只关心关键字段；新增/覆盖/删除均触发
    if (!IMPORTANT_COOKIES.has(c.name)) return;

    logYT("------------------>>>> cookie changed name:", c.name);
    refresh().then();
}

async function ensureInitialCookies() {
    const existing = await sessionGet(KS_YT_COOKIE_KEY);
    if (!existing) {
        logYT("[TweetCat] no cookie in session, capturing...");
        await refresh();
    } else {
        logYT("[TweetCat] cookie already in session, skip init capture.");
    }
}

function setupCookieWatcher() {
    if (!browser.cookies.onChanged.hasListener(onChanged)) {
        browser.cookies.onChanged.addListener(onChanged);
    }
    logYT("[TweetCat] cookie watcher started (important-only)");

    // 启动时检查 session 是否已有 cookie，没有就先生成一次
    ensureInitialCookies().catch(err =>
        console.error("[TweetCat] ensureInitialCookies failed:", err)
    );
}

setupCookieWatcher();